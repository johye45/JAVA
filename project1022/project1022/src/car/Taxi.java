/*Taxi정의*/
package car;
public class Taxi extends Car{
	//Car를 상속받았으므로, 여기서도 마찬갖로 택시만이 갖는 특징만 추가하면 됨
	//코드량이 눌고 중복작성 하지 않아도 되므로 유지보수 하기 좋다
	//oop목적은 바로 상속이다
	
	/*
	눈에 보이지 않지만 컴파일러에 의해 디폴트 생성자가 아래와 같이 아무것도 없는
	로직상태로 존재하게 된다 그래야 new Taxi()할때 에러가 안남
	그러나 문제 발생 ! 택시가 초기화하기 보다 앞서서 Car가 먼저 초기화 되어야 한다
	그래서 sun사에서는 눈에 보이지는 않지만, 자식의 디폴트 생성자에 보이지 않는
	생성자 호출을 살짝 넣어둔다
	public Taxi(){
		super();//이 생성자 호출이 숨어 있다
				super는 부모 클래스를 의미하고
				super는 부모의 생성자를 의미한다
		
		sun사에 의해 디폴트 생성자가 붐모의 생성자를 호출하는지 증명해보자
		부모의 생성자에 무언가 동작여부를 확인할 수 있는 코드를 넣어 보자
		근데, 부모인 Car에서 디폴트 생성자가 아닌, 매개변수 있는 생성자만 둘 경우
		조심해야 한다
		Taxi클래스의 디폴트 생성자에서는 무조건 super()가 들어가 있으므로,
		매개변수 없는 생성자인 Car()를 호출하고 있는것과 같다. 따라서 현재 Car에는 Car()생성자 대신에
		Car(String brand)만 존재하므로, 생성자 호출시 에러남

		해결책 ) 현재 디폴트 생성자는 우리에게 아무런 도움을 주지못하므로
		개발자가 주도해서 원하는 생성자 호출을 직접해야 한다
		즉, 생성자에게 의존 ㄴㄴ, 방치 ㄴㄴ

	}
	*/
	/*
	//부모의 매개변수 있는 생성자를 직접 호출해주기 위해, 개발자가 생성자를 정의하고 있는것임
	public Taxi(){
		super("Benz");//매개변수 있는 생성자 호출
		//이렇게 하면 존재하는 생성자를 제대로 호출하는 것이므로,
		//더이상 에러가 안남
	}*/ 
	//주석으로 막으면 다시 컴파일러가 관여함
	//디폴트생성자를 만들고 그 안에서 super()호출하게 될것임
	//그렇게 되면 오버로딩 된 생성자 중 두번째 꺼 디폴트 생성자를 호출하게
	//되어 에러가 안난다


	
	//위와같이 개발자가 직접 알맞는 생성자를 정의하는 방법을 추천하지만
	//부모 클래스에 생성자를 여러개를 정의하는 것임
	//즉 매개변수 있는것 없는것 다 정의해 놓는거다 = 오버로딩!


	//taxi특징
	public void pass(){
		System.out.println("승객을 태워요");
	}


}
